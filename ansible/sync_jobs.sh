#!/bin/bash

# Created by argbash-init v2.6.1
# ARG_POSITIONAL_SINGLE([host],[The Jenkins host entry as you have in your ssh configuration],[jenkins])
# ARG_OPTIONAL_REPEATED([job],[j],[Jobs to synchronize, pass none to auto-detect and synchronize all])
# ARG_OPTIONAL_BOOLEAN([verbose],[v])
# ARG_HELP([Synchronize jobs configurations ])
# ARG_DEFAULTS_POS()
# DEFINE_SCRIPT_DIR()
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='jvh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_host="jenkins"
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_job=()
_arg_verbose="off"

print_help ()
{
	printf '%s\n' "Synchronize jobs configurations "
	printf 'Usage: %s [-j|--job <arg>] [-v|--(no-)verbose] [-h|--help] [<host>]\n' "$0"
	printf '\t%s\n' "<host>: The Jenkins host entry as you have in your ssh configuration (default: 'jenkins')"
	printf '\t%s\n' "-j,--job: Jobs to synchronize, pass none to auto-detect and synchronize all (empty by default)"
	printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-j|--job)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_job+=("$2")
				shift
				;;
			--job=*)
				_arg_job+=("${_key##--job=}")
				;;
			-j*)
				_arg_job+=("${_key##-j}")
				;;
			-v|--no-verbose|--verbose)
				_arg_verbose="on"
				test "${1:0:5}" = "--no-" && _arg_verbose="off"
				;;
			-v*)
				_arg_verbose="on"
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_positionals+=("$1")
				;;
		esac
		shift
	done
}


handle_passed_args_count ()
{
	test ${#_positionals[@]} -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 0 and 1, but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
	_positional_names=('_arg_host' )

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || die "Couldn't determine the script's running directory, which probably matters, bailing out" 2

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# $1 File to filter out
filter_sensitive_lines_out ()
{
	sed -i '/\(gitHubAuthId\|authToken\)/d' "$1"
}

scp_verbose='-q'
test "$_arg_verbose" = off || scp_verbose=

cd_to_remote_job_directory="cd /var/lib/jenkins/jobs"
output_dirs_having_config_xml="find . -maxdepth 2 -type f -name config.xml -printf \"%h\\n\" | cut -f 2 -d /"

test "${#_arg_job[*]}" -gt 0 || _arg_job=( $(ssh "$_arg_host" "$cd_to_remote_job_directory; $output_dirs_having_config_xml | sort | uniq") )

for job_name in "${_arg_job[@]}"; do
	test "$_arg_verbose" = off || printf '%s\n' "Copying configuration for $job_name"
	local_filename="$script_dir/jobs/$job_name.xml"
	scp $scp_verbose "$_arg_host:/var/lib/jenkins/jobs/$job_name/config.xml" "$local_filename"
	test "$_arg_verbose" = off || printf '%s\n' "Filtering sensitive stuff out of $local_filename"
	filter_sensitive_lines_out "$local_filename"
done

# ] <-- needed because of Argbash
